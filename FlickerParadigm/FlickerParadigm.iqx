*******************************************************************************************************************
*******************************************************************************************************************
									FLICKER PARADIGM FOR CHANGEBLINDNESS
*******************************************************************************************************************
*******************************************************************************************************************
											Script Info

Script Author: Katja Borchert, Ph.D. (katjab@millisecond.com) for Millisecond Software, LLC
Date: 02-11-2014

last updated: 09-14-2015 by K.Borchert for Millisecond Software LLC

Copyright ©  09-14-2015 Millisecond Software
*******************************************************************************************************************
*******************************************************************************************************************
	BACKGROUND INFO
*******************************************************************************************************************
*******************************************************************************************************************
										*SCRIPT PURPOSE*

This script implements a Flicker Paradigm to investigate the role of attention in Change Blindness based on:

Rensink, R.A., O'Regan, J.K. & Clark, J.J. (1997). TO SEE OR NOT TO SEE:
The Need for Attention to Perceive Changes in Scenes. Psychological Science, 8, 368-373.


NOTES: 
* This script runs with 6 example stimuli (ONLY intended for demonstration purposes). The original study ran with
48.

* the variable "interest level of change" (central vs. marginal) is not included in this script as the example
stimuli contain "marginal interest" changes only.

* this script runs 2 cue conditions (cue vs. no cue) either in a mixed design (default) or in a blocked
design. The script does not include an unreliable cue condition as tested by Rensink et al.


Millisecond Software thanks Dr. Rensink for sharing his example stimuli for this script!


											*TASK*
Participants are presented "flickering" presentations of original and altered pictures for a maximum cycle of 1 min (default).
The task is to find the one difference between the two pictures. 
If participants find the difference they are instructed to press the Responsekey (original: Spacebar) and 
are asked to describe the change in detail in a textbox.


									  *SCRIPT SPECIFICS*

(1) EDITABLE CODE:
check under EDITABLE CODE for (relatively) easily editable values, stimuli, instructions etc. 

Keep in mind that you can use this script as a template and therefore always "mess" with the entire code to 
further customize your experiment.

If you have any questions, please don't hesitate to contact Millisecond Software.

(2) EXPERIMENTAL SET-UP : 

3 (change types: location, color, presence/absence) x  2 (cue conditions: no cue, cue); tested within
Change types are tested by default in a mixed design. To run them in a blocked design: change values.runcuecondition (editable value).
If the conditions are run in a blocked design, the order of the cue conditions is determined randomly in this script.

Cues in this script alert participants to the type of change: color, location or the addition/removal of an object

(a) Blocks:
1. Practice: by default, the script runs as many practice trials as specified under values.max_numberoftrials_practice (default: 1)
and selects the stimuli randomly from item.practice_StimA.
		NOTE: Rensink et al ran 6 (=3 changetypes x 2 interest levels; interest levels are not tested in this script by default)
2. Flicker_MixedCue: by default, the script runs 6 trials
3. Flicker_Cue/Flicker_NoCue: by default, the script runs 3 trials per block (stimuli are randomly assigned to either one of them)

(b) Trial Sequences: 
1. cue-field screen: 3000ms
	-> the cue condition is selected at random
2. blank screen: 1000ms

3. Cycle: the selection of the individual pictures is random

original (240ms) -> flicker (80ms) -> original (240ms)-> flicker (80ms) -> altered (240ms) -> flicker (240ms) -> altered (240ms) -> repeat of cycle if noresponse
(maximum cycle duration: ~1 min)

Note: all durations are editable parameter. They can be changed under EDITABLE CODE -> Editable Values

4. Change Description: if a change was reported (by pressing Responsekey): an openended trial asks participants to describe the
change in detail

(3) STIMULI
The provided stimuli are example stimuli generously shared by Dr. Rensink under 
http://www2.psych.ubc.ca/~rensink/flicker/download/index.html

They are only intended for demonstration purposes. 
Substitute your own stimuli under EDITABLE CODE -> Editable Stimuli and follow instructions

(4) INSTRUCTIONS
The instructions used in this script are not original. They are provided in html-format by Millisecond Software.
To change the instructions, simply change the html files (e.g. in 'Notepad')

(5) DATA
Check under DATA for data file information - customize if necessary

*******************************************************************************************************************
*******************************************************************************************************************
	EDITABLE CODE: The code in this section can be easily altered (look for additional instructions were indicated)
*******************************************************************************************************************
*******************************************************************************************************************

***************************************************************************************
*********************************************
Editable Values
*********************************************
***************************************************************************************
/responsekey:							scancode of the response key
											Note: scancodes under Tools -> Keyboard Scancodes (original: 57)
/responsekey_label:						label of the response key (original: <SPACEBAR>)

/cueboxheight:							height of the cuebox in percentage of canvas height (original: 10%)
/cueboxwidth:							width of the cuebox in percentage of canvas width (original: 30%)
/cuetextheight:							the height of the cue text in percentage of canvas height (original: 5%)

/picheight:								the height of the pictures in percentage of canvas height (original: 70%)

/cueduration:							the duration of the cue (original: 3000ms)
/startscreenduration:					the duration of the start screen (original: 1000ms)
/StimA_Duration:						the duration of the original picture (original: 240ms)
											Note: the original picture is presented twice. If values.flicker_same = 0; 
											the presentation of the 2 original pictures appears continuous
/StimB_Duration:						the duration of the altered picture (original: 240ms)
											Note: the altered picture is presented twice. If values.flicker_same = 0; 
											the presentation of the 2 altered pictures appears continuous

/flicker_same:							the duration of the blank screen/flicker in between the 2 presentations of the original pictures (or altered pictures) (original: 80ms)
											Note: if set to 0 the presentation of the pictures appears continuous
/flicker_different:						the duration of the blank screen/the flicker in between original and altered pictures (original: 80ms)

/max_cycleduration:						the ~maximum duration of the cycling through original and altered pictures if no response occurs (defaul: 60000ms)

/max_numberoftrials:					the number of test stimuli (default: 6).
											NOTES:
											a) In the mixed design all stimuli are presented within one block. In the blocked design, half
											the stimuli are presented in the cue, the other half in the nocue block (random sampling).
											b) The original study (Rensink et al used 48 stimuli)-> change images under EDITABLE CODE -> Editable Stimuli

/max_numberoftrials_practice:			the number of practice stimuli tested (default: 1)
											
/runcuecondition:						by default, the cuecondition (cue vs. no cue) is run in a "mixed" design; to run the
										cuecondition in a blocked design, set value.runcuecondition = "blocked"

						
<values>
/responsekey = 57
/responsekey_label = "SPACEBAR"

/cueboxheight = 10%
/cueboxwidth = 60%
/cuetextheight = 5%

/picheight = 70%

/cueduration = 3000
/startscreenduration = 1000
/StimA_Duration = 240
/StimB_Duration = 240
/flicker_same = 80
/flicker_different = 80

/max_cycleduration = 60000

/max_numberoftrials  = 6
/max_numberoftrials_practice = 1

/runcuecondition = "mixed"
</values>


***************************************************************************************
*********************************************
Editable Stimuli
*********************************************
***************************************************************************************

*******************************
Pictures
*******************************
NOTES: 
* the example pictures are listed separately for location, presence/absence, and color changes
* the number of pictures under each item need to be equal to values.max_numberoftrials/3
assuming that each stimulus is run once in this paradigm

* The example pictures contain ONLY marginal interest changes.

*  the original study ran 48/3 = 16 stimuli under each of the 3 change categories

*****************************
Stimuli with Location Changes
******************************

<item stimsA_location>
/1 = "female/location1a.jpg"
/2 = "female/location2a.jpg"
</item>

<item stimsB_location>
/1 = "female/location1b.jpg"
/2 = "female/location2b.jpg" 
</item> 

*****************************
Stimuli with Presence/Absence Changes
******************************

<item stimsA_presence>
/1 = "AirplaneA_P.png"
/2 = "HarborsideA_P.png"
</item>

<item stimsB_presence>
/1 = "AirplaneB_P.png"
/2 = "HarborsideB_P.png"
</item>

*****************************
Stimuli with Color Changes
******************************
<item stimsA_color>
/1 = "MoneyA_C.png"
/2 = "MarketA_C.png"
</item>

<item stimsB_color>
/1 = "MoneyB_C.png"
/2 = "MarketB_C.png"
</item>

*****************************
Practice Stimuli
*****************************

<item practice_stimA>
/1 = "CornerA_C.png"
</item>

<item practice_stimB>
/1 = "CornerB_C.png"
</item>

***************************************************************************************
*********************************************
Editable Instructions
*********************************************
***************************************************************************************

Note: edit the instructions to report the observed changes here
<item reportchanges>
/1 = "Please describe what changed in the pictures in the textbox below. Be as specific as you can be."
</item>


<instruct>
/windowsize = (90%, 90%)
/ fontstyle = ("Arial", 3.00%, false, false, false, false, 5, 1)
/ txcolor = (black)
/ finishlabel = "SPACEBAR to continue"
/nextkey = (57)
/nextlabel = "SPACEBAR to continue"
/prevkey = (28)
/prevlabel = "ENTER to go back"
</instruct>


Most instruction pages are provided in html-format: to edit the instructions, open the provided htm documents
in a simple text editor such as Notepad (for example) and edit instructions in the htm document directly.

<htmlpage Intro1>
/file = "FlickerParadigm_Intro1.htm"
</htmlpage>

<htmlpage Intro2>
/file = "FlickerParadigm_Intro2.htm"
</htmlpage>

<htmlpage Intro3>
/file = "FlickerParadigm_Intro3.htm"
</htmlpage>

<htmlpage Practice>
/file = "FlickerParadigm_Practice.htm"
</htmlpage>

<htmlpage PracticeEnd>
/file = "FlickerParadigm_PracticeEnd.htm"
</htmlpage>

<htmlpage MixedCue>
/file = "FlickerParadigm_mixedcue.htm"
</htmlpage>

<htmlpage NoCue>
/file = "FlickerParadigm_nocue.htm"
</htmlpage>

<htmlpage Cue>
/file = "FlickerParadigm_cue.htm"
</htmlpage>

<page end>
You have reached the end of the study. Thank you for your participation!
</page>

*******************************************************************************************************************
*******************************************************************************************************************
	DATA: this section contains data file information
*******************************************************************************************************************
*******************************************************************************************************************

********************
raw data
********************
date, time, subject:			date and time script was run with the current subjectnumber 
blockcode, blocknum:			the name and number of the current block
trialcode, trialnum: 			the name and number of the currently recorded trial
									Note: not all trials that are run might record data
/flicker_same:					the duration of the blank screen/flicker in between the 2 presentations of the original pictures (or altered pictures) (original: 80ms)
									Note: if set to 0 the presentation of the pictures appears continuous
/changetype:					"location" (1), "presence/absence" (2), "color" changes (3) in the pictures
/cuecondition:					1 = a cue is given; 2 = no cue is given
/cue:							the currently presented cue
/counttrials:					counts the number of trials 
/count_cycles: 					counts the number of cycles started until a response occurs
/currentpic:					the itemnumber of the currently presented (original/altered) pic
/stimulus:						the stimulus presented (StimA)

/response:						the participant's response
									Note: trial.savedata will have response = 0

/responsepoint:					determines the stimulus in the response cycle (the cycle that participant made a positive response)
								that was presented when participant made response: 
								"StimA1", "flicker_AA", "StimA2", "flicker_AB", "StimB1",
								"flicker_BB", "StimB2", "flicker_BA" or "N/A" (if no response was given)
/alternations:					determines the number of alternations between original and altered pictures until response occurs
									Note: each switch between originals and altered pictures as well as each switch between
											altered pictures and original pictures is counted as an alternation.
											=> for each completed cycle, participant go through 2 alternations;
											if the response occurs AFTER the change from original to altered pic in the last
											cycle, one more alternation is added to the count.
											
latency: 						the response latency in a given trial
									Note: trial.savedata will have latency = 0
/cycle_rt:						stores the combined trial latencies across the entire cycle until response occurs
/textboxresponse:				stores the openended response
correct:						the correctness of the response (trial.savedata -> correct = 0)
									Note: script does NOT evaluate the correctness of the openended.reportchange response automatically.
									Each openended response needs to be evaluated separately.
/textboxresponse_rt:			stores the time it took participant to work on the openended response until pressing the button


<data>
/file = "FlickerParadigm_rawdata.iqdat"
/columns = [date, time, subject, group, blockcode, blocknum, trialcode, trialnum, 
values.flicker_same, values.changetype, values.cuecondition, values.cue, 
values.counttrials, values.count_cycles, values.currentpic, values.stimulus,
response, values.responsepoint, values.alternations, latency, values.cycle_rt, 
 values.textboxresponse, correct, values.textboxresponse_rt]
/separatefiles = true
</data>


********************
summary data
********************
script.startdate:				date script was run
script.starttime:				time script was started
script.subjectid:				subject id number
script.groupid:					group id number
script.elapsedtime:				time it took to run script (in ms)
/completed:						0 = script was not completed; 1 = script was completed (all conditions run)


/runcuecondition:	by default, the cuecondition (cue vs. no cue) is run in a "mixed" design; to run the
				    cuecondition in a blocked design, set value.runcuecondition = "blocked"

<summarydata >
/file = "FlickerParadigm_summary.iqdat"
/columns = [script.startdate, script.starttime, script.subjectid, script.groupid, script.elapsedtime, values.completed, values.runcuecondition]
</summarydata>


*******************************************************************************************************************
*******************************************************************************************************************
							REMAINING CODE: Customize after careful consideration only
*******************************************************************************************************************
*******************************************************************************************************************

*******************************************************************************************************************
*******************************************************************************************************************
	DEFAULTS:
*******************************************************************************************************************
*******************************************************************************************************************
requires Inquisit 4.0.4.0

<defaults>
/minimumversion = "4.0.4.0"
/canvasaspectratio = (4,3)
/screencolor = black    
</defaults>

*******************************************************************************************************************
*******************************************************************************************************************
	VALUES: automatically updated
*******************************************************************************************************************
*******************************************************************************************************************
/completed:								0 = script was not completed; 1 = script was completed (all conditions run)

/cue:									the currently presented cue
/currentpic:							the itemnumber of the currently presented pic
/stimulus:								the stimulus run (StimA)

/changetype:							"location", "presence/absence", "color" changes in the pictures
/cuecondition:							1 = a cue is given; 2 = no cue is given (default unless values.runcuecondition = true)

/count_cycles: 							counts the number of cycles started until a response occurs
/alternations:							determines the alternations between original and altered pictures until response occurs
											Note: each switch between originals and altered pictures as well as each switch between
													altered pictures and original pictures is counted as an alternation.
													=> for each completed cycle, participant go through 2 alternations;
													if the response occurs after the change from original to altered pic in the last
													cycle, one more alternation is added to the count.

/counttrials:							counts the number of trials  

/cycle_rt:								stores the combined cycle latencies across cycles until response occurs
/presentationtime:						stores the presentation time of one cycle
/current_cycleduration:					stores the maximum remaining time the current cycle continues if no response occurs

/responsepoint:							determines the stimulus in the response cycle (the cycle that participant made a positive response)
										that was presented when participant made response

/responsepoint_set:						helper variable to determine values.responsepoint

/textboxresponse:						stores the openended response
/textboxresponse_rt:					stores the time it took participant to work on the openended response until pressing the button


<values>
/completed = 0
/cue = ""
/currentpic = 0
/stimulus = ""

/changetype = 0
/cuecondition = 0

/count_cycles = 0
/alternations = 0
/counttrials = 0

/cycle_rt = 0
/presentationtime = 0
/current_cycleduration = 0

/responsepoint = ""
/responsepoint_set = 0
/textboxresponse = "" 
/textboxresponse_rt = 0
</values>

*******************************************************************************************************************
*******************************************************************************************************************
	STIMULI
*******************************************************************************************************************
*******************************************************************************************************************

**************************************
Helper Stimulus
**************************************

<shape eraser>
/shape = rectangle
/size = (100%, 100%)
/color = (black)
/position = (50%, 50%)
</shape>

**************************************
Cue Stimulus
**************************************

<text cue>
/items = ("<%values.cue%>")
/txbgcolor = (white)
/txcolor = (black)
/size = (values.cueboxwidth, values.cueboxheight)
/ fontstyle = ("Arial", values.cuetextheight, false, false, false, false, 5, 1)
/position = (50%, 50%)
/ hjustify = center
/vjustify = center
</text>


********************************
Practice Stimuli
********************************

<picture StimA_practice>
/items = practice_stimA
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

<picture StimB_practice>
/items = practice_stimB
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

*****************************************
Picture Stimuli by ChangeType
*****************************************

<picture StimA_location>
/items = stimsA_location
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

<picture StimB_location>
/items = stimsB_location
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

<picture StimA_presence>
/items = stimsA_presence
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

<picture StimB_presence>
/items = stimsB_presence
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

<picture StimA_color>
/items = stimsA_color
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

<picture StimB_color>
/items = stimsB_color
/select = values.currentpic
/size = (100%, values.picheight)
/position = (50%, 50%)
/erase = false
</picture>

*********************************************
Instruction Text for openended.reportchange
*********************************************

<text reportchange>
/items = reportchanges
/select = 1
/position = (50%, 30%) 
/ fontstyle = ("Arial", 3%, false, false, false, false, 5, 1)
/ txcolor = (white)
/txbgcolor = (black)
</text>

*******************************************************************************************************************
*******************************************************************************************************************
	LISTS
*******************************************************************************************************************
*******************************************************************************************************************

***********************************
Practice Lists
***********************************

Note: this list randomly selects one of the practice pictures for the practice sessions
<list picitemnumbers_practice>
/poolsize = values.max_numberoftrials_practice
/replace = false
/resetinterval = 1
</list>

***********************************
Test Lists: MIXED design
***********************************

Note: selects randomly without replacement a trial sequence presenting stimuli with location (1), presence/absence (2) or color changes
=> each change type trial sequence is selected equally often
<list changetype_Mixed>
/items = (1, 2, 3)
/poolsize = values.max_numberoftrials
/replace = false
/resetinterval = 1
</list>

***********************************
Test Lists: BLOCKED design
***********************************

Note: selects randomly without replacement a trial sequence presenting stimuli with location (1), presence/absence (2) or color changes
=> each change type trial sequence is selected equally often
<list changetype_Blocked>
/items = (1, 2, 3)
/poolsize = values.max_numberoftrials/2
/replace = false
/resetinterval = 1
</list>

************************************************
Stimulus Selection
************************************************

Note: this list randomly selects one of the test pictures for the test session for the location trial sequence
!!! the number of stimuli depend on values.max_numberoftrials and assumes that item.stimsa_location
contains 1/3 of all trials that will be presented
!!!/resetinterval = 2 to assure random sampling of half the stimuli into the cue condition;
the other half into the no cue condition if the block design is run (values.runcuecondition = "blocked").

<list location_picitemnumbers>
/poolsize = (values.max_numberoftrials/3)
/replace = false
/resetinterval = 2
</list>

Note: this list randomly selects one of the test pictures for the test session for the presence/absence trial sequence
!!! the number of stimuli depend on values.max_numberoftrials and assumes that item.stimsa_presence
contains 1/3 of all trials that will be presented
<list presence_picitemnumbers>
/poolsize = (values.max_numberoftrials/3)
/replace = false
/resetinterval = 2
</list>

Note: this list randomly selects one of the test pictures for the test session for the color trial sequence
!!! the number of stimuli depend on values.max_numberoftrials and assumes that item.stimsa_color
contains 1/3 of all trials that will be presented
<list color_picitemnumbers>
/poolsize = (values.max_numberoftrials/3)
/replace = false
/resetinterval = 2
</list>


*************************************************************
Cue Lists for Mixed Cue Trials
*************************************************************
these lists are used for block.flicker_mixedcue.
Half the trials are assigned a cue (1); the other half do not get cues (2).

<list location_cuecondition_mixed>
/items = (1,2)
/poolsize = values.max_numberoftrials/3
/replace = false
/resetinterval = 1
</list>

<list presence_cuecondition_mixed>
/items = (1,2)
/poolsize = values.max_numberoftrials/3
/replace = false
/resetinterval = 1
</list>

<list color_cuecondition_mixed>
/items = (1,2)
/poolsize = values.max_numberoftrials/3
/replace = false
/resetinterval = 1
</list>

*******************************************************************************************************************
*******************************************************************************************************************
	TRIALS
*******************************************************************************************************************
*******************************************************************************************************************

*************************************
all experimental conditions
*************************************

Note:
* trial.selectchangetype randomly without replacement selects the next trial sequence depending on changetype (location, presence, color)
=> same number of location, presence, color trial sequences are run
<trial selectchangetype>
/ontrialbegin = [values.counttrials += 1]
/ontrialbegin = [values.textboxresponse = ""; values.textboxresponse_rt = ""]
/ontrialbegin = [if (values.runcuecondition == "mixed") values.changetype = list.changetype_Mixed.nextvalue else values.changetype = list.changetype_blocked.nextvalue]
/branch = [if (values.changetype == 1) trial.cue_location]
/branch = [if (values.changetype == 2) trial.cue_presence]
/branch = [if (values.changetype == 3) trial.cue_color]
/trialduration = 0
/recorddata = false
</trial>

Note: openended.reportchange provides a textbox after each trial sequence to write in the specific change that was noticed (a response is required);
IF the max number of trials hasn't be run yet, trial.selectchangetype is called once again to determine the next trial sequence.
<openended reportchange>
/ buttonlabel = "CTRL-ENTER to finish"
/charlimit = 20000
/multiline = true
/ numlines = 25
/position = (50%, 70%)
/size = (50%, 20%)
/stimulusframes = [1 = reportchange]
/required = true
/recorddata = false
/ontrialend = [values.textboxresponse = openended.reportchange.response; values.textboxresponse_rt = openended.reportchange.latency]
/branch = [trial.savedata]
</openended>

<trial savedata>
/trialduration = 0
/recorddata = true
/branch = [if (script.currentblock == "practice" && values.counttrials < values.max_numberoftrials_practice) trial.practicesequence]
/branch = [if (script.currentblock != "practice" && values.runcuecondition == "mixed" && values.counttrials < values.max_numberoftrials) trial.selectchangetype]
/branch = [if (script.currentblock != "practice" && values.runcuecondition != "mixed" && values.counttrials < (values.max_numberoftrials/2)) trial.selectchangetype]
</trial>

******************************************************************
Trial Sequence that presents stimuli with location changes
*******************************************************************

Notes:
- trial.cue_location resets necessary variables
- trial.cue_location randomly selects pictures (random selection without replacement)
and determines values.interesttype (central/marginal) based on the selected itemnumber
- trial.cue_location presents the selected cue for a predetermined time (values.cueduration)
- calls trial.startscreen_location


/ontrialbegin = [if (script.currentblock == "practice" && values.currentpic <= (item.originalpics_practice.itemcount/2) ) values.interesttype = "central" else values.interesttype = "marginal"]

<trial cue_location>
/ontrialbegin = [values.count_cycles = 0; values.alternations = 0]
/ontrialbegin = [values.cycle_rt = 0]
/ontrialbegin = [values.responsepoint_set = 0; values.responsepoint = ""]
/ontrialbegin = [values.presentationtime = (2*values.StimA_Duration) + (2*values.StimB_Duration) + (2*values.flicker_different) + (2*values.flicker_same)]
/ontrialbegin = [values.current_cycleduration = values.max_cycleduration]

/ontrialbegin = [values.currentpic = list.location_picitemnumbers.nextindex]

/ontrialbegin = [values.cuecondition = 2]
/ontrialbegin = [if (script.currentblock == "flicker_cue") values.cuecondition = 1]
/ontrialbegin = [if (script.currentblock == "flicker_mixedcue") values.cuecondition = list.location_cuecondition_mixed.nextvalue]
/ontrialbegin = [if (values.cuecondition == 1) values.cue = "location change" else values.cue = ""]

/stimulusframes = [1 = eraser, cue]
/trialduration = values.cueduration
/recorddata = false
/branch = [trial.startscreen_location]
</trial>

Note: trial presents a blank screen for a pre-determined time (values.startscreenduration)
and then calls trial.cycle_location
<trial startscreen_location>
/stimulusframes = [1 = eraser]
/trialduration = values.startscreenduration
/branch = [trial.cycle_location]
/recorddata = false
</trial>

Notes:
- trial.cycle_location checks if values.presentationtime needs to be adjusted (this is the case if the max duration of the cycle is almost 
up and there is not enough time for the regular presentation of one cycle)
- trial.cycle_location dynamically inserts items into the stimulusframes (a dynamic way is chosen to allow max. flexibility in
changing presentationtimes)
- trial.cycle_location calls itself over and over again until a) a response is given or b) values.max_cycleduration is reached.
Whichever comes first.
- calls trial.determineresponsepoint_location when cycle is completed
<trial cycle_location>
/ontrialbegin = [if (values.current_cycleduration <= values.presentationtime) values.presentationtime = values.current_cycleduration]
/ontrialbegin = [values.count_cycles += 1]

/ontrialbegin = [trial.cycle_location.insertstimulustime(picture.stima_location, 0)]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_location.insertstimulustime(shape.eraser, values.StimA_Duration)}]
/ontrialbegin = [trial.cycle_location.insertstimulustime(picture.stima_location, (values.StimA_Duration + values.flicker_same))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_location.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same))]
/ontrialbegin = [trial.cycle_location.insertstimulustime(picture.stimb_location, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different))]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_location.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration))}]
/ontrialbegin = [trial.cycle_location.insertstimulustime(picture.stimb_location, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_location.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)))]
/ontrialend = [trial.cycle_location.resetstimulusframes()]

/beginresponsetime = 0
/responseinterrupt = immediate
/isvalidresponse = [trial.cycle_location.response == values.responsekey]
/monkeyresponse = (57, 0)

/ontrialend = [values.stimulus = picture.stima_location.currentitem]
/ontrialend = [values.cycle_rt += trial.cycle_location.latency]

/trialduration = (values.presentationtime)
/branch = [if (values.presentationtime < values.current_cycleduration && trial.cycle_location.response != values.responsekey) {
									values.current_cycleduration -= values.presentationtime;
									trial.cycle_location}]
/branch = [trial.determineresponsepoint_location]
/recorddata = false
</trial>


Note: trial.determineresponsepoint_location determines 
* the stimulus that was presented at the time of the response; if no response was given, values.responsepoint = "N/A"
* the number of alternations before response based on values.responsepoint and values.count_cycles
<trial determineresponsepoint_location>
/ontrialbegin = [if (trial.cycle_location.latency <= values.StimA_Duration) 
							{values.responsepoint = "StimA1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_location.latency <= (values.StimA_Duration + values.flicker_same) )
							{values.responsepoint = "flicker_AA"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_location.latency <= ((2*values.StimA_Duration) + values.flicker_same) )
							{values.responsepoint = "StimA2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_location.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different) )
							{values.responsepoint = "flicker_AB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_location.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "StimB1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_location.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "flicker_BB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_location.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)) )
							{values.responsepoint = "StimB2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_location.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + (2*values.flicker_different) + (2*values.StimB_Duration)) )
							{values.responsepoint = "flicker_BA"; values.responsepoint_set = 1}]

/ontrialbegin = [if (values.responsepoint == "StimA1") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AA") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimA2") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AB") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimB1") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BB") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "StimB2") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BA") values.alternations = (values.count_cycles - 1) * 2 + 1]

/ontrialbegin = [if (trial.cycle_location.response != values.responsekey) {values.responsepoint = "N/A"}]

/trialduration = 0
/recorddata = false
/branch = [if (trial.cycle_location.response == values.responsekey) openended.reportchange else trial.savedata]
</trial>

******************************************************************
Trial Sequence that presents stimuli with presence/absence changes
*******************************************************************

Notes:
- trial.cue_location resets necessary variables
- trial.cue_location randomly selects pictures (random selection without replacement)
and determines values.interesttype (central/marginal) based on the selected itemnumber
- trial.cue_location presents the selected cue for a predetermined time (values.cueduration)
- calls trial.startscreen_location
<trial cue_presence>
/ontrialbegin = [values.count_cycles = 0; values.alternations = 0]
/ontrialbegin = [values.cycle_rt = 0]
/ontrialbegin = [values.responsepoint_set = 0; values.responsepoint = ""]
/ontrialbegin = [values.presentationtime = (2*values.StimA_Duration) + (2*values.StimB_Duration) + (2*values.flicker_different) + (2*values.flicker_same)]
/ontrialbegin = [values.current_cycleduration = values.max_cycleduration]

/ontrialbegin = [values.currentpic = list.presence_picitemnumbers.nextindex]

/ontrialbegin = [values.cuecondition = 2]
/ontrialbegin = [if (script.currentblock == "flicker_cue") values.cuecondition = 1]
/ontrialbegin = [if (script.currentblock == "flicker_mixedcue") values.cuecondition = list.presence_cuecondition_mixed.nextvalue]
/ontrialbegin = [if (values.cuecondition == 1) values.cue = "presence/absence change" else values.cue = ""]
/stimulusframes = [1 = eraser, cue]
/trialduration = values.cueduration
/recorddata = false
/branch = [trial.startscreen_presence]
</trial>

Note: trial presents a blank screen for a pre-determined time (values.startscreenduration)
and then calls trial.cycle_presence
<trial startscreen_presence>
/stimulusframes = [1 = eraser]
/trialduration = values.startscreenduration
/branch = [trial.cycle_presence]
/recorddata = false
</trial>

Notes:
- trial.cycle_presence checks if values.presentationtime needs to be adjusted (this is the case if the max duration of the cycle is almost 
up and there is not enough time for the regular presentation of one cycle)
- trial.cycle_presence dynamically inserts items into the stimulusframes (a dynamic way is chosen to allow max. flexibility in
changing presentationtimes)
- trial.cycle_presence calls itself over and over again until a) a response is given or b) values.max_cycleduration is reached.
Whichever comes first.
- calls trial.determineresponsepoint_presence when cycle is completed
<trial cycle_presence>
/ontrialbegin = [if (values.current_cycleduration <= values.presentationtime) values.presentationtime = values.current_cycleduration]
/ontrialbegin = [values.count_cycles += 1]

/ontrialbegin = [trial.cycle_presence.insertstimulustime(picture.stima_presence, 0)]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_presence.insertstimulustime(shape.eraser, values.StimA_Duration)}]
/ontrialbegin = [trial.cycle_presence.insertstimulustime(picture.stima_presence, (values.StimA_Duration + values.flicker_same))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_presence.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same))]
/ontrialbegin = [trial.cycle_presence.insertstimulustime(picture.stimb_presence, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different))]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_presence.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration))}]
/ontrialbegin = [trial.cycle_presence.insertstimulustime(picture.stimb_presence, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_presence.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)))]
/ontrialend = [trial.cycle_presence.resetstimulusframes()]

/beginresponsetime = 0
/responseinterrupt = immediate
/isvalidresponse = [trial.cycle_presence.response == values.responsekey]
/monkeyresponse = (57, 0)

/ontrialend = [values.stimulus = picture.stima_presence.currentitem]
/ontrialend = [values.cycle_rt += trial.cycle_presence.latency]

/trialduration = (values.presentationtime)
/branch = [if (values.presentationtime < values.current_cycleduration && trial.cycle_presence.response != values.responsekey) {
									values.current_cycleduration -= values.presentationtime;
									trial.cycle_presence}]
/branch = [trial.determineresponsepoint_presence]
/recorddata = false
</trial>


Note: trial.determineresponsepoint_presence determines 
* the stimulus that was presented at the time of the response; if no response was given, values.responsepoint = "N/A"
* the number of alternations before response based on values.responsepoint and values.count_cycles
<trial determineresponsepoint_presence>
/ontrialbegin = [if (trial.cycle_presence.latency <= values.StimA_Duration) 
							{values.responsepoint = "StimA1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_presence.latency <= (values.StimA_Duration + values.flicker_same) )
							{values.responsepoint = "flicker_AA"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_presence.latency <= ((2*values.StimA_Duration) + values.flicker_same) )
							{values.responsepoint = "StimA2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_presence.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different) )
							{values.responsepoint = "flicker_AB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_presence.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "StimB1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_presence.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "flicker_BB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_presence.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)) )
							{values.responsepoint = "StimB2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_presence.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + (2*values.flicker_different) + (2*values.StimB_Duration)) )
							{values.responsepoint = "flicker_BA"; values.responsepoint_set = 1}]

/ontrialbegin = [if (values.responsepoint == "StimA1") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AA") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimA2") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AB") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimB1") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BB") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "StimB2") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BA") values.alternations = (values.count_cycles - 1) * 2 + 1]

/ontrialbegin = [if (trial.cycle_presence.response != values.responsekey) {values.responsepoint = "N/A"}]

/trialduration = 0
/recorddata = false
/branch = [if (trial.cycle_presence.response == values.responsekey) openended.reportchange else trial.savedata]
</trial>

******************************************************************
Trial Sequence that presents stimuli with color changes
*******************************************************************

Notes:
- trial.cue_color resets necessary variables
- trial.cue_color randomly selects pictures (random selection without replacement)
and determines values.interesttype (central/marginal) based on the selected itemnumber
- trial.cue_color presents the selected cue for a predetermined time (values.cueduration)
- calls trial.startscreen_color
<trial cue_color>
/ontrialbegin = [values.count_cycles = 0; values.alternations = 0]
/ontrialbegin = [values.cycle_rt = 0]
/ontrialbegin = [values.responsepoint_set = 0; values.responsepoint = ""]
/ontrialbegin = [values.presentationtime = (2*values.StimA_Duration) + (2*values.StimB_Duration) + (2*values.flicker_different) + (2*values.flicker_same)]
/ontrialbegin = [values.current_cycleduration = values.max_cycleduration]

/ontrialbegin = [values.currentpic = list.color_picitemnumbers.nextindex]

/ontrialbegin = [values.cuecondition = 2]
/ontrialbegin = [if (script.currentblock == "flicker_cue") values.cuecondition = 1]
/ontrialbegin = [if (script.currentblock == "flicker_mixedcue") values.cuecondition = list.color_cuecondition_mixed.nextvalue]
/ontrialbegin = [if (values.cuecondition == 1) values.cue = "color change" else values.cue = ""]

/stimulusframes = [1 = eraser, cue]
/trialduration = values.cueduration
/recorddata = false
/branch = [trial.startscreen_color]
</trial>

Note: trial presents a blank screen for a pre-determined time (values.startscreenduration)
and then calls trial.cycle_color
<trial startscreen_color>
/stimulusframes = [1 = eraser]
/trialduration = values.startscreenduration
/branch = [trial.cycle_color]
/recorddata = false
</trial>

Notes:
- trial.cycle_color checks if values.presentationtime needs to be adjusted (this is the case if the max duration of the cycle is almost 
up and there is not enough time for the regular presentation of one cycle)
- trial.cycle_color dynamically inserts items into the stimulusframes (a dynamic way is chosen to allow max. flexibility in
changing presentationtimes)
- trial.cycle_color calls itself over and over again until a) a response is given or b) values.max_cycleduration is reached.
Whichever comes first.
- calls trial.determineresponsepoint_color when cycle is completed
<trial cycle_color>
/ontrialbegin = [if (values.current_cycleduration <= values.presentationtime) values.presentationtime = values.current_cycleduration]
/ontrialbegin = [values.count_cycles += 1]

/ontrialbegin = [trial.cycle_color.insertstimulustime(picture.stima_color, 0)]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_color.insertstimulustime(shape.eraser, values.StimA_Duration)}]
/ontrialbegin = [trial.cycle_color.insertstimulustime(picture.stima_color, (values.StimA_Duration + values.flicker_same))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_color.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same))]
/ontrialbegin = [trial.cycle_color.insertstimulustime(picture.stimb_color, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different))]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_color.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration))}]
/ontrialbegin = [trial.cycle_color.insertstimulustime(picture.stimb_color, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_color.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)))]
/ontrialend = [trial.cycle_color.resetstimulusframes()]

/beginresponsetime = 0
/responseinterrupt = immediate
/isvalidresponse = [trial.cycle_color.response == values.responsekey]
/monkeyresponse = (57, 0)

/ontrialend = [values.stimulus = picture.stima_color.currentitem]
/ontrialend = [values.cycle_rt += trial.cycle_color.latency]

/trialduration = (values.presentationtime)
/branch = [if (values.presentationtime < values.current_cycleduration && trial.cycle_color.response != values.responsekey) {
									values.current_cycleduration -= values.presentationtime;
									trial.cycle_color}]
/branch = [trial.determineresponsepoint_color]
/recorddata = false
</trial>

Note: trial.determineresponsepoint_color determines 
* the stimulus that was presented at the time of the response; if no response was given, values.responsepoint = "N/A"
* the number of alternations before response based on values.responsepoint and values.count_cycles
<trial determineresponsepoint_color>
/ontrialbegin = [if (trial.cycle_color.latency <= values.StimA_Duration) 
							{values.responsepoint = "StimA1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_color.latency <= (values.StimA_Duration + values.flicker_same) )
							{values.responsepoint = "flicker_AA"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_color.latency <= ((2*values.StimA_Duration) + values.flicker_same) )
							{values.responsepoint = "StimA2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_color.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different) )
							{values.responsepoint = "flicker_AB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_color.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "StimB1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_color.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "flicker_BB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_color.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)) )
							{values.responsepoint = "StimB2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_color.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + (2*values.flicker_different) + (2*values.StimB_Duration)) )
							{values.responsepoint = "flicker_BA"; values.responsepoint_set = 1}]

/ontrialbegin = [if (values.responsepoint == "StimA1") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AA") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimA2") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AB") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimB1") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BB") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "StimB2") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BA") values.alternations = (values.count_cycles - 1) * 2 + 1]

/ontrialbegin = [if (trial.cycle_color.response != values.responsekey) {values.responsepoint = "N/A"}]

/trialduration = 0
/recorddata = false
/branch = [if (trial.cycle_color.response == values.responsekey) openended.reportchange else trial.savedata]
</trial>

******************************************************************
Trial Sequence for practice sequences
*******************************************************************

Notes:
- trial.cue_location resets necessary variables
- trial.cue_location randomly selects pictures (random selection without replacement)
and determines values.interesttype (central/marginal) based on the selected itemnumber
- trial.cue_location presents the selected cue for a predetermined time (values.cueduration)
- calls trial.startscreen_location


/ontrialbegin = [if (script.currentblock == "practice" && values.currentpic <= (item.originalpics_practice.itemcount/2) ) values.interesttype = "central" else values.interesttype = "marginal"]

<trial practicesequence>
/ontrialbegin = [values.counttrials += 1]
/ontrialbegin = [values.count_cycles = 0; values.alternations = 0]
/ontrialbegin = [values.cycle_rt = 0]
/ontrialbegin = [values.responsepoint_set = 0; values.responsepoint = ""]
/ontrialbegin = [values.presentationtime = (2*values.StimA_Duration) + (2*values.StimB_Duration) + (2*values.flicker_different) + (2*values.flicker_same)]
/ontrialbegin = [values.current_cycleduration = values.max_cycleduration]

/ontrialbegin = [values.currentpic = list.picitemnumbers_practice.nextindex]
/ontrialbegin = [values.changetype = "practice"]
/ontrialbegin = [values.cuecondition = 2]
/ontrialbegin = [values.cue = ""]

/stimulusframes = [1 = eraser, cue]
/trialduration = values.cueduration
/recorddata = false
/branch = [trial.startscreen_practice]
</trial>

Note: trial presents a blank screen for a pre-determined time (values.startscreenduration)
and then calls trial.cycle_practice
<trial startscreen_practice>
/stimulusframes = [1 = eraser]
/trialduration = values.startscreenduration
/branch = [trial.cycle_practice]
/recorddata = false
</trial>

Notes:
- trial.cycle_practice checks if values.presentationtime needs to be adjusted (this is the case if the max duration of the cycle is almost 
up and there is not enough time for the regular presentation of one cycle)
- trial.cycle_practice dynamically inserts items into the stimulusframes (a dynamic way is chosen to allow max. flexibility in
changing presentationtimes)
- trial.cycle_practice calls itself over and over again until a) a response is given or b) values.max_cycleduration is reached.
Whichever comes first.
- calls trial.determineresponsepoint_practice when cycle is completed
<trial cycle_practice>
/ontrialbegin = [if (values.current_cycleduration <= values.presentationtime) values.presentationtime = values.current_cycleduration]
/ontrialbegin = [values.count_cycles += 1]

/ontrialbegin = [trial.cycle_practice.insertstimulustime(picture.StimA_practice, 0)]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_practice.insertstimulustime(shape.eraser, values.StimA_Duration)}]
/ontrialbegin = [trial.cycle_practice.insertstimulustime(picture.StimA_practice, (values.StimA_Duration + values.flicker_same))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_practice.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same))]
/ontrialbegin = [trial.cycle_practice.insertstimulustime(picture.StimB_practice, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different))]
/ontrialbegin = [if (values.flicker_same > 0) {
						trial.cycle_practice.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration))}]
/ontrialbegin = [trial.cycle_practice.insertstimulustime(picture.StimB_practice, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration))]
/ontrialbegin = [if (values.flicker_different > 0) trial.cycle_practice.insertstimulustime(shape.eraser, ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)))]
/ontrialend = [trial.cycle_practice.resetstimulusframes()]

/beginresponsetime = 0
/responseinterrupt = immediate
/isvalidresponse = [trial.cycle_practice.response == values.responsekey]
/monkeyresponse = (57, 0)

/ontrialend = [values.stimulus = picture.stima_practice.currentitem]
/ontrialend = [values.cycle_rt += trial.cycle_practice.latency]

/trialduration = (values.presentationtime)
/branch = [if (values.presentationtime < values.current_cycleduration && trial.cycle_practice.response != values.responsekey) {
									values.current_cycleduration -= values.presentationtime;
									trial.cycle_practice}]
/branch = [trial.determineresponsepoint_practice]
/recorddata = false
</trial>


Note: trial.determineresponsepoint_practice determines 
* the stimulus that was presented at the time of the response; if no response was given, values.responsepoint = "N/A"
* the number of alternations before response based on values.responsepoint and values.count_cycles
<trial determineresponsepoint_practice>
/ontrialbegin = [if (trial.cycle_practice.latency <= values.StimA_Duration) 
							{values.responsepoint = "StimA1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_practice.latency <= (values.StimA_Duration + values.flicker_same) )
							{values.responsepoint = "flicker_AA"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_practice.latency <= ((2*values.StimA_Duration) + values.flicker_same) )
							{values.responsepoint = "StimA2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_practice.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different) )
							{values.responsepoint = "flicker_AB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_practice.latency <= ((2*values.StimA_Duration) + values.flicker_same + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "StimB1"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_practice.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + values.StimB_Duration) )
							{values.responsepoint = "flicker_BB"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_practice.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + values.flicker_different + (2*values.StimB_Duration)) )
							{values.responsepoint = "StimB2"; values.responsepoint_set = 1}]
/ontrialbegin = [if (values.responsepoint_set != 1 && trial.cycle_practice.latency <= ((2*values.StimA_Duration) + (2*values.flicker_same) + (2*values.flicker_different) + (2*values.StimB_Duration)) )
							{values.responsepoint = "flicker_BA"; values.responsepoint_set = 1}]

/ontrialbegin = [if (values.responsepoint == "StimA1") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AA") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimA2") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "flicker_AB") values.alternations = (values.count_cycles - 1) * 2]
/ontrialbegin = [if (values.responsepoint == "StimB1") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BB") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "StimB2") values.alternations = (values.count_cycles - 1) * 2 + 1]
/ontrialbegin = [if (values.responsepoint == "flicker_BA") values.alternations = (values.count_cycles - 1) * 2 + 1]

/ontrialbegin = [if (trial.cycle_practice.response != values.responsekey) {values.responsepoint = "N/A"}]

/trialduration = 0
/recorddata = false
/branch = [if (trial.cycle_practice.response == values.responsekey) openended.reportchange else trial.savedata]
</trial>

*******************************************************************************************************************
*******************************************************************************************************************
	BLOCKS
*******************************************************************************************************************
*******************************************************************************************************************

<block practice>
/preinstructions = (Practice)
/postinstructions = (PracticeEnd)
/onblockbegin  = [values.counttrials = 0]
/trials = [1 = practicesequence]
</block>

NOTES:
* block.flicker_mixedcue only runs if values.runcuecondition = "mixed"
* it runs as many trials as specified by values.max_numberoftrials
<block flicker_mixedcue>
/preinstructions = (MixedCue)
/skip = [values.runcuecondition != "mixed"]
/onblockbegin  = [values.counttrials = 0]
/trials = [1 = selectchangetype]
</block>

NOTES:
* block.flickercue/block.flicker_mixedcue only runs if values.runcuecondition is NOT "mixed"
* it runs half the trials as specified by values.max_numberoftrials (as the stimuli
have to be randomly divided between 2 conditions)

<block flicker_nocue>
/preinstructions = (NoCue)
/skip = [values.runcuecondition == "mixed"]
/onblockbegin  = [values.counttrials = 0]
/trials = [1 = selectchangetype]
</block>

<block flicker_cue>
/preinstructions = (Cue)
/skip = [values.runcuecondition == "mixed"]
/onblockbegin  = [values.counttrials = 0]
/trials = [1 = selectchangetype]
</block>

*******************************************************************************************************************
*******************************************************************************************************************
	EXPERIMENT
*******************************************************************************************************************
*******************************************************************************************************************
The default order of the experiment is

1. block.practice
2. block.flicker_mixedcue IF values.runcuecondition = "mixed"

IF values.runcuecondition == "blocked": block.flicker_mixedcue is skipped and the script randomly selects the order
of block.flicker_cue and block.flicker_nocue

<expt >
/preinstructions = (Intro1, Intro2, Intro3)
/postinstructions = (end)
/blocks = [1= practice; 2 = flicker_mixedcue; 3-4 = noreplace(flicker_nocue, flicker_cue)]
/onexptend = [values.completed = 1]
</expt>

*******************************************************************************************************************
												End of File
*******************************************************************************************************************